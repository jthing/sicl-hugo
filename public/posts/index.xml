<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on SICL Compiler</title>
    <link>//jthing.github.io/cicl-hugo/posts/</link>
    <description>Recent content in Posts on SICL Compiler</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 26 Apr 2025 00:00:00 +0200</lastBuildDate>
    <atom:link href="//jthing.github.io/cicl-hugo/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SICL Library reference</title>
      <link>//jthing.github.io/cicl-hugo/posts/sicl-libs/</link>
      <pubDate>Sat, 26 Apr 2025 00:00:00 +0200</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/sicl-libs/</guid>
      <description>&lt;h2 id=&#34;sicl-library-reference&#34;&gt;SICL Library reference&lt;/h2&gt;&#xA;&lt;p&gt;The chief developer of SICL Robert Strandh (beach) has come up with a website which&#xA;describes the name and function of the SICL libraries. Their name and function.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://metamodular.com/SICL-related-libraries/sicl-related-libraries.html&#34;&gt;SICL-related libraries&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Codeberg</title>
      <link>//jthing.github.io/cicl-hugo/posts/codeberg/</link>
      <pubDate>Thu, 30 Jan 2025 00:00:00 +0100</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/codeberg/</guid>
      <description>&lt;h2 id=&#34;codeberg&#34;&gt;Codeberg&lt;/h2&gt;&#xA;&lt;p&gt;The Clappers repository has moved to Codeberg.&#xA;&lt;a href=&#34;https://codeberg.org/jpthing/Clappers&#34;&gt;https://codeberg.org/jpthing/Clappers&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Clappers</title>
      <link>//jthing.github.io/cicl-hugo/posts/clappers/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0100</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/clappers/</guid>
      <description>&lt;h2 id=&#34;clappers&#34;&gt;Clappers&lt;/h2&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;../images/SICL-Structure.svg&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;That is a basic outline of how I laid things out at present. Clash is just a&#xA;Mock for now. The real development effort is put into Clector and Massa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cleavir</title>
      <link>//jthing.github.io/cicl-hugo/posts/cleavir/</link>
      <pubDate>Fri, 16 Aug 2024 00:00:00 +0200</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/cleavir/</guid>
      <description>&lt;h2 id=&#34;cleavir&#34;&gt;Cleavir&lt;/h2&gt;&#xA;&lt;p&gt;This is a continuation of Strands SICL (SICL implements Common&#xA;Lisp). Although most of the compiler can itself be written in Common&#xA;Lisp  to be a compliant Compiler it must eventually compile  to&#xA;machine code. Today this is done by the SBCL compiler. To make the&#xA;compiler work standalone this will need to be implemented and thus I have drafted this&#xA;proposal. It is criteria that the compiler need to be fast and good. A speed&#xA;goal for the generated code would be to be within a factor of 3 of a C compiler. The&#xA;compiler itself must compile fast similarly to the SBCL compiler today or&#xA;better. As SICL itself it is written in Common lisp.This is a preliminary draft of my&#xA;ideas of how this can be accomplished, subject approval by Dr Strand.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bibliography</title>
      <link>//jthing.github.io/cicl-hugo/posts/bibliography/</link>
      <pubDate>Sun, 07 Apr 2024 00:00:00 +0200</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/bibliography/</guid>
      <description>&lt;h2 id=&#34;bibliography&#34;&gt;Bibliography&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-picture-mode&#34; data-lang=&#34;picture-mode&#34;&gt;&#xA;@book{allenOptimizingCompilersModern2001,&#xA;  title = {Optimizing Compilers for Modern Architectures: A Dependence-Based Approach},&#xA;  shorttitle = {Optimizing Compilers for Modern Architectures},&#xA;  author = {Allen, Randy and Kennedy, Ken},&#xA;  date = {2001},&#xA;  edition = {1st ed},&#xA;  publisher = {Morgan Kaufmann Publishers},&#xA;  location = {San Francisco},&#xA;  isbn = {978-1-55860-286-1},&#xA;  pagetotal = {790},&#xA;  keywords = {Computer architecture,Optimizing compilers}&#xA;}&#xA;&#xA;@article{appelSSAFunctionalProgramming1998,&#xA;  title = {{{SSA}} Is Functional Programming},&#xA;  author = {Appel, Andrew W.},&#xA;  date = {1998-04},&#xA;  journaltitle = {ACM SIGPLAN Notices},&#xA;  shortjournal = {SIGPLAN Not.},&#xA;  volume = {33},&#xA;  number = {4},&#xA;  pages = {17--20},&#xA;  issn = {0362-1340, 1558-1160},&#xA;  doi = {10.1145/278283.278285},&#xA;  url = {https://dl.acm.org/doi/10.1145/278283.278285},&#xA;  urldate = {2024-03-09},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/RNTL2HK5/Appel - 1998 - SSA is functional programming.pdf}&#xA;}&#xA;&#xA;@book{barendregtLambdaCalculusIts1984,&#xA;  title = {The Lambda Calculus: Its Syntax and Semantics},&#xA;  shorttitle = {The Lambda Calculus},&#xA;  author = {Barendregt, H. P.},&#xA;  date = {1984},&#xA;  series = {Studies in Logic and the Foundations of Mathematics},&#xA;  edition = {Rev. ed},&#xA;  number = {v. 103},&#xA;  publisher = {{North-Holland ; Sole distributors for the U.S.A. and Canada, Elsevier Science Pub. Co}},&#xA;  location = {Amsterdam ; New York : New York, N.Y},&#xA;  isbn = {978-0-444-86748-3 978-0-444-87508-2},&#xA;  pagetotal = {621},&#xA;  keywords = {Lambda calculus}&#xA;}&#xA;&#xA;@book{biereHandbookSatisfiability2009,&#xA;  title = {Handbook of Satisfiability},&#xA;  editor = {Biere, Armin},&#xA;  date = {2009},&#xA;  series = {Frontiers in Artificial Intelligence and Applications},&#xA;  number = {v. 185},&#xA;  publisher = {IOS Press},&#xA;  location = {Amsterdam, The Netherlands ; Washington, DC},&#xA;  isbn = {978-1-58603-929-5},&#xA;  pagetotal = {966},&#xA;  keywords = {Algebra Boolean,Algorithmus,Anwendung,Berechnungskomplexität,Computer algorithms,Congresses,Decision making,Erfüllbarkeitsproblem,Propositional calculus},&#xA;  annotation = {OCLC: ocn290492523}&#xA;}&#xA;&#xA;@article{clickSimpleGraphBasedIntermediate,&#xA;  title = {A {{Simple Graph-Based Intermediate Representation}}},&#xA;  author = {Click, Cliff and Paleczny, Michael},&#xA;  abstract = {We present a graph-based intermediate representation (IR) with simple semantics and a low-memory-cost C++ implementation. The IR uses a directed graph with labeled vertices and ordered inputs but unordered outputs. Vertices are labeled with opcodes, edges are unlabeled. We represent the CFG and basic blocks with the same vertex and edge structures. Each opcode is defined by a C++ class that encapsulates opcode-specific data and behavior. We use inheritance to abstract common opcode behavior, allowing new opcodes to be easily defined from old ones. The resulting IR is simple, fast and easy to use.},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/685NSKUM/Click og Paleczny - A Simple Graph-Based Intermediate Representation.pdf}&#xA;}&#xA;&#xA;@inreference{ContinuationpassingStyle2023,&#xA;  title = {Continuation-Passing Style},&#xA;  booktitle = {Wikipedia},&#xA;  date = {2023-11-02T15:32:49Z},&#xA;  url = {https://en.wikipedia.org/w/index.php?title=Continuation-passing_style&amp;amp;oldid=1183163457},&#xA;  urldate = {2024-03-03},&#xA;  abstract = {In functional programming, continuation-passing style (CPS) is a style of programming in which control is passed explicitly in the form of a continuation. This is contrasted with direct style, which is the usual style of programming. Gerald Jay Sussman and Guy L. Steele, Jr. coined the phrase in AI Memo 349 (1975), which sets out the first version of the Scheme programming language.John C. Reynolds gives a detailed account of the numerous discoveries of continuations.A function written in continuation-passing style takes an extra argument: an explicit &amp;#34;continuation&amp;#34;; i.e., a function of one argument.  When the CPS function has computed its result value, it &amp;#34;returns&amp;#34; it by calling the continuation function with this value as the argument. That means that when invoking a CPS function, the calling function is required to supply a procedure to be invoked with the subroutine&amp;#39;s &amp;#34;return&amp;#34; value.  Expressing code in this form makes a number of things explicit which are implicit in direct style.  These include: procedure returns, which become apparent as calls to a continuation; intermediate values, which are all given names; order of argument evaluation, which is made explicit; and tail calls, which simply call a procedure with the same continuation, unmodified, that was passed to the caller. Programs can be automatically transformed from direct style to CPS. Functional and logic compilers often use CPS as an intermediate representation where a compiler for an imperative or procedural programming language would use static single assignment form (SSA). SSA is formally equivalent to a subset of CPS (excluding non-local control flow, which does not occur when CPS is used as intermediate representation). Functional compilers can also use A-normal form (ANF) (but only for languages requiring eager evaluation), rather than with &amp;#39;thunks&amp;#39; (described in the examples below) in CPS.  CPS is used more frequently by compilers than by programmers as a local or global style.},&#xA;  langid = {english},&#xA;  annotation = {Page Version ID: 1183163457},&#xA;  file = {/home/john/Zotero/storage/44YKD49Q/Continuation-passing_style.html}&#xA;}&#xA;&#xA;@video{CrashCourseModern,&#xA;  entrysubtype = {video},&#xA;  title = {A Crash Course in Modern Hardware by Cliff Click},&#xA;  url = {https://www.youtube.com/watch?v=OFgxAFdxYAQ},&#xA;  urldate = {2024-02-26},&#xA;  abstract = {I walk through a tiny performance example on a modern out-of-order CPU, and basically show that (1) single-threaded performance is tapped out, (2) all the ac...},&#xA;  langid = {norwegianbokmal},&#xA;  file = {/home/john/Zotero/storage/72W3PQHJ/watch.html}&#xA;}&#xA;&#xA;@book{daveyIntroductionLatticesOrder2010a,&#xA;  title = {Introduction to Lattices and Order},&#xA;  author = {Davey, Brian A. and Priestley, Hilary A. and Davey, B. A.},&#xA;  date = {2010},&#xA;  edition = {2. ed., 5. printing},&#xA;  publisher = {Cambridge Univ. Press},&#xA;  location = {Cambridge},&#xA;  isbn = {978-0-521-78451-1},&#xA;  langid = {english},&#xA;  pagetotal = {298}&#xA;}&#xA;&#xA;@article{deanTrainingCompilersBetter,&#xA;  title = {Training {{Compilers}} for {{Better Inlining Decisions}}},&#xA;  author = {Dean, Jeffrey and Chambers, Craig},&#xA;  abstract = {Optimizing implementations for object-oriented languages rely on aggressive inlining to achieve good performance. Sometimes the compiler is over-eager in its quest for good performance, however, and inlines too many methods that merely increase compile time and consume extra compiled code space with little benefit in run-time performance. We have designed and implemented a new approach to inlining decision making in which the compiler performs inlining experimentally and records the results in a database that can be consulted to guide future inlining decisions of the same routine at call sites that have similar static information. Central to our approach is a new technique, called type group analysis, that calculates how much of the static information available at a call site was profitably used during inlining. The results of type group analysis enable the compiler to compute a generalization of the actual static information for a particular experiment, significantly increasing reuse of database entries. Preliminary results indicate that compile time is almost cut in half with only a 15\% reduction in run-time performance.},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/XKKX2VT6/Dean og Chambers - Training Compilers for Better Inlining Decisions.pdf}&#xA;}&#xA;&#xA;@article{durandRemovingRedundantTests,&#xA;  title = {Removing Redundant Tests by Replicating Control Paths},&#xA;  author = {Durand, Irène and Strandh, Robert},&#xA;  abstract = {We describe a technique for removing redundant tests in intermediate code by replicating the control paths between two identical tests, the second of which is dominated by the first. The two replicas encode different outcomes of the test, making it possible to remove the second of the two. Our technique uses local graph rewriting, making its correctness easy to prove. We also present a proof that the rewriting always terminates. This technique can be used to eliminate multiple tests that occur naturally such as the test for consness when both car and cdr are applied to the same object, but we also show how this technique can be used to automatically create specialized versions of general code, for example in order to create fast specialized versions of sequence functions such as find depending on the type of the sequence and the values of the keyword arguments supplied.},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/G6RUD3V3/Durand og Strandh - Removing redundant tests by replicating control pa.pdf}&#xA;}&#xA;&#xA;@article{flanaganEssenceCompilingContinuations,&#xA;  title = {The {{Essence}} of {{Compiling}} with {{Continuations}}},&#xA;  author = {Flanagan, Cormac and Sabry, Amr and Duba, Bruce F and Felleisen, Matthias},&#xA;  abstract = {In order to simplify the compilation process, many compilers for higher-order languages use the continuationpassing style (CPS) transformation in a rst phase to generate an intermediate representation of the source program. The salient aspect of this intermediate form is that all procedures take an argument that represents the rest of the computation (the \textbackslash continuation&amp;#34;). Since the na ve CPS transformation considerably increases the size of programs, CPS compilers perform reductions to produce a more compact intermediate representation. Although often implemented as a part of the CPS transformation, this step is conceptually a second phase. Finally, code generators for typical CPS compilers treat continuations specially in order to optimize the interpretation of continuation parameters.},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/69GCBY46/Flanagan et al. - The Essence of Compiling with Continuations.pdf}&#xA;}&#xA;&#xA;@article{ghalayiniExplicitRefinementTypes2023,&#xA;  title = {Explicit {{Refinement Types}}},&#xA;  author = {Ghalayini, Jad Elkhaleq and Krishnaswami, Neel},&#xA;  date = {2023-08-30},&#xA;  journaltitle = {Proceedings of the ACM on Programming Languages},&#xA;  shortjournal = {Proc. ACM Program. Lang.},&#xA;  volume = {7},&#xA;  pages = {187--214},&#xA;  issn = {2475-1421},&#xA;  doi = {10.1145/3607837},&#xA;  url = {https://dl.acm.org/doi/10.1145/3607837},&#xA;  urldate = {2024-03-16},&#xA;  abstract = {JAD ELKHALEQ GHALAYINI, University of Cambridge, United Kingdom NEEL KRISHNASWAMI, University of Cambridge, United Kingdom We present ert, a type theory supporting refinement types with explicit proofs. Instead of solving refinement constraints with an SMT solver like DML and Liquid Haskell, our system requires and permits programmers to embed proofs of properties within the program text, letting us support a rich logic of properties including quantifiers and induction. We show that the type system is sound by showing that every refined program erases to a simply-typed program, and by means of a denotational semantics, we show that every erased program has all of the properties demanded by its refined type. All of our proofs are formalised in Lean 4. CCS Concepts: • Theory of computation → Program verification; Denotational semantics.},&#xA;  issue = {ICFP},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/LAEY3ZEX/Ghalayini og Krishnaswami - 2023 - Explicit Refinement Types.pdf}&#xA;}&#xA;&#xA;@book{hennessyComputerArchitectureQuantitative2012,&#xA;  title = {Computer Architecture: A Quantitative Approach},&#xA;  shorttitle = {Computer Architecture},&#xA;  author = {Hennessy, John L. and Patterson, David A. and Asanović, Krste},&#xA;  date = {2012},&#xA;  edition = {5. ed},&#xA;  publisher = {Elsevier, Morgan Kaufmann},&#xA;  location = {Amsterdam Heidelberg},&#xA;  isbn = {978-0-12-383872-8 978-93-81269-22-0},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/6UVS69MQ/Hennessy et al. - 2012 - Computer architecture a quantitative approach.pdf}&#xA;}&#xA;&#xA;@article{holzleDebuggingOptimizedCode,&#xA;  title = {Debugging {{Optimized Code}} with {{Dynamic Deoptimization}}},&#xA;  author = {Hölzle, Urs and Chambers, Craig and Ungar, David},&#xA;  abstract = {SELF’s debugging system provides complete source-level debugging (expected behavior) with globally optimized code. It shields the debugger from optimizations performed by the compiler by dynamically deoptimizing code on demand. Deoptimization only affects the procedure activations that are actively being debugged; all other code runs at full speed. Deoptimization requires the compiler to supply debugging information at discrete interrupt points; the compiler can still perform extensive optimizations between interrupt points without affecting debuggability. At the same time, the inability to interrupt between interrupt points is invisible to the user. Our debugging system also handles programming changes during debugging. Again, the system provides expected behavior: it is possible to change a running program and immediately observe the effects of the change. Dynamic deoptimization transforms old compiled code (which may contain inlined copies of the old version of the changed procedure) into new versions reflecting the current source-level state. To the best of our knowledge, SELF is the first practical system providing full expected behavior with globally optimized code.},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/HKKSAV7V/Hölzle et al. - Debugging Optimized Code with Dynamic Deoptimizati.pdf}&#xA;}&#xA;&#xA;@online{HttpsBibliographySelflanguage,&#xA;  title = {{{https://bibliography.selflanguage.org/\_static/dynamic-deoptimization.pdf}}},&#xA;  url = {https://bibliography.selflanguage.org/_static/dynamic-deoptimization.pdf},&#xA;  urldate = {2024-03-25}&#xA;}&#xA;&#xA;@book{jacobsCategoricalLogicType1999,&#xA;  title = {Categorical Logic and Type Theory},&#xA;  author = {Jacobs, Bart},&#xA;  date = {1999},&#xA;  series = {Studies in Logic and the Foundations of Mathematics},&#xA;  edition = {1st ed},&#xA;  number = {v. 141},&#xA;  publisher = {Elsevier Science},&#xA;  location = {Amsterdam ; New York},&#xA;  isbn = {978-0-444-50170-7},&#xA;  pagetotal = {760},&#xA;  keywords = {Categories (Mathematics),Type theory}&#xA;}&#xA;&#xA;@article{jerinicSEMANTICSTHEOREMSA_LispKit1992,&#xA;  title = {{{SEMANTICS THEOREMS OF A}}\_{{LispKit Lisp PROGRAMMING LANGUAGE}}},&#xA;  author = {Jerinic, Ljubomir},&#xA;  date = {1992-10-24},&#xA;  journaltitle = {Bulletins for Applied Mathematics, Volume LXV, BAM 861/93, 307-318},&#xA;  url = {https://www.academia.edu/2937935/SEMANTICS_THEOREMS_OF_A_LispKit_Lisp_PROGRAMMING_LANGUAGE},&#xA;  urldate = {2024-03-18},&#xA;  abstract = {A\_LispKit Lisp programming language is described in terms of denotational semantics approach. The functional programming language A\_LispKit Lisp, developed in the Institute of Mathematics Novi Sad in 1991/92, is described, by a new technique of the},&#xA;  langid = {english}&#xA;}&#xA;&#xA;@book{jonesGarbageCollectionAlgorithms2007,&#xA;  title = {Garbage Collection: Algorithms for Automatic Dynamic Memory Management},&#xA;  shorttitle = {Garbage Collection},&#xA;  author = {Jones, Richard and Lins, Rafael},&#xA;  date = {2007},&#xA;  edition = {Reprinted October 2007},&#xA;  publisher = {Wiley},&#xA;  location = {Chichester},&#xA;  isbn = {978-0-471-94148-4},&#xA;  langid = {english},&#xA;  pagetotal = {379}&#xA;}&#xA;&#xA;@article{kelseyCorrespondenceContinuationPassing,&#xA;  title = {A {{Correspondence}} between {{Continuation Passing Style}} and {{Static Single Assignment Form}}},&#xA;  author = {Kelsey, Richard A},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/I24WPJWX/Kelsey - A Correspondence between Continuation Passing Styl.pdf}&#xA;}&#xA;&#xA;@book{khedkerDataFlowAnalysis2009,&#xA;  title = {Data Flow Analysis: Theory and Practice},&#xA;  shorttitle = {Data Flow Analysis},&#xA;  author = {Khedker, Uday and Sanyal, Amitabha and Karkare, Bageshri},&#xA;  date = {2009},&#xA;  publisher = {CRC Press/Taylor \&amp;amp; Francis},&#xA;  location = {Boca Raton, FL},&#xA;  isbn = {978-0-8493-2880-0},&#xA;  pagetotal = {386},&#xA;  keywords = {Compilers (Computer programs),Computer software,Data flow computing,Software engineering,Verification},&#xA;  annotation = {OCLC: ocn300030552}&#xA;}&#xA;&#xA;@inproceedings{muchnickAdvancedCompilerDesign1997,&#xA;  title = {Advanced {{Compiler Design}} and {{Implementation}}},&#xA;  author = {Muchnick, S. S.},&#xA;  date = {1997},&#xA;  url = {https://www.semanticscholar.org/paper/Advanced-Compiler-Design-and-Implementation-Muchnick/9364b48b83244e432d970414cb3659cd0d0a23da},&#xA;  urldate = {2024-03-14},&#xA;  abstract = {Advanced Compiler Design and Implementation by Steven Muchnick Preface 1 Introduction to Advanced Topics 1.1 Review of Compiler Structure 1.2 Advanced Issues in Elementary Topics 1.3 The Importance of Code Optimization 1.4 Structure of Optimizing Compilers 1.5 Placement of Optimizations in Aggressive Optimizing Compilers 1.6 Reading Flow Among the Chapters 1.7 Related Topics Not Covered in This Text 1.8 Target Machines Used in Examples 1.9 Number Notations and Data Sizes 1.10 Wrap-Up 1.11 Further Reading 1.12 Exercises 2 Informal Compiler Algorithm Notation (ICAN) 2.1 Extended Backus-Naur Form Syntax Notation 2.2 Introduction to ICAN 2.3 A Quick Overview of ICAN 2.4 Whole Programs 2.5 Type Definitions 2.6 Declarations 2.7 Data Types and Expressions 2.8 Statements 2.9 Wrap-Up 2.10 Further Reading 2.11 Exercises 3 Symbol-Table Structure 3.1 Storage Classes, Visibility, and Lifetimes 3.2 Symbol Attributes and Symbol-Table Entries 3.3 Local Symbol-Table Management 3.4 Global Symbol-Table Structure 3.5 Storage Binding and Symbolic Registers 3.6 Approaches to Generating Loads and Stores 3.7 Wrap-Up 3.8 Further Reading 3.9 Exercises 4 Intermediate Representations 4.1 Issues in Designing an Intermediate Language 4.2 High-Level Intermediate Languages 4.3 Medium-Level Intermediate Languages 4.4 Low-Level Intermediate Languages 4.5 Multi-Level Intermediate Languages 4.6 Our Intermediate Languages: MIR, HIR, and LIR 4.7 Representing MIR, HIR, and LIR in ICAN 4.8 ICAN Naming of Data Structures and Routines that Manipulate Intermediate Code 4.9 Other Intermediate-Language Forms 4.10 Wrap-Up 4.11 Further Reading 4.12 Exercises 5 Run-Time Support 5.1 Data Representations and Instructions 5.2 Register Usage 5.3 The Local Stack Frame 5.4 The Run-Time Stack 5.5 Parameter-Passing Disciplines 5.6 Procedure Prologues, Epilogues, Calls, and Returns 5.7 Code Sharing and Position-Independent Code 5.8 Symbolic and Polymorphic Language Support 5.9 Wrap-Up 5.10 Further Reading 5.11 Exercises 6 Producing Code Generators Automatically 6.1 Introduction to Automatic Generation of Code Generators 6.2 A Syntax-Directed Technique 6.3 Introduction to Semantics-Directed Parsing 6.4 Tree Pattern Matching and Dynamic Programming 6.5 Wrap-Up 6.6 Further Reading 6.7 Exercises 7 Control-Flow Analysis 7.1 Approaches to Control-Flow Analysis 7.2 Depth-First Search, Preorder Traversal, Postorder Traversal, and Breadth-First Search 7.3 Dominators 7.4 Loops and Strongly Connected Components 7.5 Reducibility 7.6 Interval Analysis and Control Trees 7.7 Structural Analysis 7.8 Wrap-Up 7.9 Further Reading 7.10 Exercises 8 Data-Flow Analysis 8.1 An Example: Reaching Definitions 8.2 Basic Concepts: Lattices, Flow Functions, and Fixed Points 8.3 Taxonomy of Data-Flow Problems and Solution Methods 8.4 Iterative Data-Flow Analysis 8.5 Lattices of Flow Functions 8.6 Control-Tree-Based Data-Flow Analysis 8.7 Structural Analysis 8.8 Interval Analysis 8.9 Other Approaches 8.10 Du-Chains, Ud-Chains, and Webs 8.11 Static Single-Assignment (SSA) Form 8.12 Dealing with Arrays, Structures, and Pointers 8.13 Automating Construction of Data-Flow Analyzers 8.14 More Ambitious Analyses 8.15 Wrap-Up 8.16 Further Reading 8.17 Exercises 9 Dependence Analysis and Dependence Graph 9.1 Dependence Relations 9.2 Basic-Block Dependence DAGs 9.3 Dependences in Loops 9.4 Dependence Testing 9.5 Program-Dependence Graphs 9.6 Dependences Between Dynamically Allocated Objects 9.7 Wrap-Up 9.8 Further Reading 9.9 Exercises 10 Alias Analysis 10.1 Aliases in Various Real Programming Languages 10.2 The Alias Gatherer 10.3 The Alias Propagator 10.4 Wrap-Up 10.5 Further Reading 10.6 Exercises 11 Introduction to Optimization 11.1 Global Optimizations Discussed in Chapters 12 Through 18 11.2 Flow Sensitivity and May vs. Must Information 11.3 Importance of Individual Optimizations 11.4 Order and Repetition of Optimizations 11.5 Further Reading 11.6 Exercises 12 Early Optimizations 12.1 Constant-Expression Evaluation (Constant Folding) 12.2 Scalar Replacement of Aggregates 12.3 Algebraic Simplifications and Reassociation 12.4 Value Numbering 12.5 Copy Propagation 12.6 Sparse Conditional Constant Propagation 12.7 Wrap-Up 12.8 Further Reading 12.9 Exercises 13 Redundancy Elimination 13.1 Common-Subexpression Elimination 13.2 Loop-Invariant Code Motion 13.3 Partial-Redundancy Elimination 13.4 Redundancy Elimination and Reassociation 13.5 Code Hoisting 13.6 Wrap-Up 13.7 Further Reading 13.8 Exercises 14 Loop Optimizations 14.1 Induction-Variable Optimizations 14.2 Unnecessary Bounds-Checking Elimination 14.3 Wrap-Up 14.4 Further Reading 14.5 Exercises 15 Procedure Optimizations 15.1 Tail-Call Optimization and Tail-Recursion Elimination 15.2 Procedure Integration 15.3 In-Line Expansion 15.4 Leaf-Routine Optimization and Shrink Wrapping 15.5 Wrap-Up 15.6 Further Reading 15.7 Exercises 16 Register Allocation 16.1 Register Allocation and Assignment 16.2 Local Methods 16.3 Graph Coloring 16.4 Priority-Based Graph Coloring 16.5 Other Approaches to Register Allocation 16.6 Wrap-Up 16.7 Further Reading 16.8 Exercises 17 Code Scheduling 17.1 Instruction Scheduling 17.2 Speculative Loads and Boosting 17.3 Speculative Scheduling 17.4 Software Pipelining 17.5 Trace Scheduling 17.6 Percolation Scheduling 17.7 Wrap-Up 17.8 Further Reading 17.9 Exercises 18 Control-Flow and Low-Level Optimizations 18.1 Unreachable-Code Elimination 18.2 Straightening 18.3 If Simplifications 18.4 Loop Simplifications 18.5 Loop Inversion 18.6 Unswitching 18.7 Branch Optimizations 18.8 Tail Merging or Cross Jumping 18.9 Conditional Moves 18.10 Dead-Code Elimination 18.11 Branch Prediction 18.12 Machine Idioms and Instruction Combining 18.13 Wrap-Up 18.14 Further Reading 18.15 Exercises 19 Interprocedural Analysis and Optimization 19.1 Interprocedural Control-Flow Analysis: The Call Graph 19.2 Interprocedural Data-Flow Analysis 19.3 Interprocedural Constant Propagation 19.4 Interprocedural Alias Analysis 19.5 Interprocedural Optimizations 19.6 Interprocedural Register Allocation 19.7 Aggregation of Global References 19.8 Other Issues in Interprocedural Program Management 19.9 Wrap-Up 19.10 Further Reading 19.11 Exercises 20 Optimization of the Memory Hierarchy 20.1 Impact of Data and Instruction Caches 20.2 Instruction-Cache Optimization 20.3 Scalar Replacement of Array Elements 20.4 Data-Cache Optimization 20.5 Scalar vs. Memory-Oriented Optimizations 20.6 Wrap-Up 20.7 Further Reading 20.8 Exercises 21 Case Studies of Compilers and Future Trends 21.1 the Sun Compilers for SPARC 21.2 The IBM XL Compilers for the POWER and PowerPC Architectures 21.3 Digital Equipment&amp;#39;s Compilers for Alpha 21.4 The Intel Reference Compilers for the Intel 386 Architecture 21.5 Future Trends in Compiler Design and Implementation 21.6 Further Reading A Guide to Assembly Languages Used in This Book A.1 Sun SPARC Versions 8 and 9 Assembly Language A.2 IBM POWER and PowerPC Assembly Language A.3 DEC Alpha Assembly Language A.4 Intel 386 Architecture Assembly Language A.5 Hewlett-Packard&amp;#39;s PA-RISC Assembly Language B Representation of Sets, Sequences, Trees, DAGs, and Functions B.1 Representation of Sets B.2 Representation of Sequences B.3 Representation of Trees and DAGs B.4 Representation of Functions B.5 Further Reading C Software Resources View Appendix C with live links to download sites C.1 Finding and Accessing Software on the Internet C.2 Machine Simulators C.3 Compilers C.4 Code-Generator Generators: BURG and IBURG C.5 Profiling Tools Bibliography Indices}&#xA;}&#xA;&#xA;@book{muchnickAdvancedCompilerDesign1997a,&#xA;  title = {Advanced Compiler Design and Implementation},&#xA;  author = {Muchnick, Steven S.},&#xA;  date = {1997},&#xA;  publisher = {Morgan Kaufmann Publishers},&#xA;  location = {San Francisco},&#xA;  isbn = {978-1-55860-320-2},&#xA;  langid = {english}&#xA;}&#xA;&#xA;@book{nipkowConcreteSemanticsIsabelle2014,&#xA;  title = {Concrete {{Semantics}}: {{With Isabelle}}/{{HOL}}},&#xA;  shorttitle = {Concrete {{Semantics}}},&#xA;  author = {Nipkow, Tobias and Klein, Gerwin},&#xA;  date = {2014},&#xA;  publisher = {Springer International Publishing},&#xA;  location = {Cham},&#xA;  doi = {10.1007/978-3-319-10542-0},&#xA;  url = {https://link.springer.com/10.1007/978-3-319-10542-0},&#xA;  urldate = {2024-03-11},&#xA;  isbn = {978-3-319-10541-3 978-3-319-10542-0},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/W9MJL6F9/Nipkow og Klein - 2014 - Concrete Semantics With IsabelleHOL.pdf}&#xA;}&#xA;&#xA;@book{nipkowConcreteSemanticsIsabelle2014a,&#xA;  title = {Concrete {{Semantics}}: {{With Isabelle}}/{{HOL}}},&#xA;  shorttitle = {Concrete {{Semantics}}},&#xA;  author = {Nipkow, Tobias and Klein, Gerwin},&#xA;  date = {2014},&#xA;  publisher = {Springer International Publishing},&#xA;  location = {Cham},&#xA;  doi = {10.1007/978-3-319-10542-0},&#xA;  url = {https://link.springer.com/10.1007/978-3-319-10542-0},&#xA;  urldate = {2024-03-13},&#xA;  isbn = {978-3-319-10541-3 978-3-319-10542-0},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/DWUHAE9A/Nipkow og Klein - 2014 - Concrete Semantics With IsabelleHOL.pdf}&#xA;}&#xA;&#xA;@book{pierceAdvancedTopicsTypes2005,&#xA;  title = {Advanced Topics in Types and Programming Languages},&#xA;  editor = {Pierce, Benjamin C.},&#xA;  date = {2005},&#xA;  publisher = {MIT Press},&#xA;  location = {Cambridge, Mass.},&#xA;  abstract = {Substructural type systems / David Walker -- Dependent types / David Aspinall and Martin Hofmann -- Effect types and region-based memory management / Fritz Henglein, Henning Makholm, and Henning Niss -- Typed assembly language / Greg Morrisett -- Proof-carrying code / George Necula -- Logical relations and a case study in equivalence checking / Karl Crary -- Typed operational reasoning / Andrew Pitts -- Design considerations for ML-style module systems / Robert Harper and Benjamin C. Pierce -- Type definitions / Christopher A. Stone -- The essence of ML type inference / Fran(c)ʹois Pottier and Didier R(c)♭my.y},&#xA;  isbn = {978-0-262-16228-9},&#xA;  langid = {english},&#xA;  pagetotal = {574},&#xA;  file = {/home/john/Zotero/storage/MMH8AGBM/Pierce - 2005 - Advanced topics in types and programming languages.pdf}&#xA;}&#xA;&#xA;@book{pierceTypesProgrammingLanguages2002,&#xA;  title = {Types and Programming Languages},&#xA;  author = {Pierce, Benjamin C.},&#xA;  date = {2002},&#xA;  publisher = {MIT Press},&#xA;  location = {Cambridge, Mass},&#xA;  isbn = {978-0-262-16209-8},&#xA;  pagetotal = {623},&#xA;  keywords = {Programming languages (Electronic computers)}&#xA;}&#xA;&#xA;@book{queinnecLispSmallPieces2003,&#xA;  title = {Lisp in Small Pieces},&#xA;  author = {Queinnec, Christian and Callaway, Kathleen and Queinnec, Christian and Queinnec, Christian},&#xA;  date = {2003},&#xA;  edition = {1. paperback ed},&#xA;  publisher = {Cambridge Univ. Press},&#xA;  location = {Cambridge},&#xA;  isbn = {978-0-521-54566-2 978-0-521-56247-8},&#xA;  langid = {english},&#xA;  pagetotal = {514}&#xA;}&#xA;&#xA;@article{rao2006UpdateClemens,&#xA;  title = {2006 {{Update Clemens Fruhwirth}} {$&amp;lt;$}clemens@endorphin.Org{$&amp;gt;$} {{The McCLIM Project}}},&#xA;  author = {Rao, Ramana},&#xA;  langid = {english},&#xA;  file = {/home/john/Zotero/storage/9FQDUQRQ/Rao - 2006 Update Clemens Fruhwirth clemens@endorphin.o.pdf}&#xA;}&#xA;&#xA;@online{RegisterAllocationAlgorithms2020,&#xA;  title = {Register {{Allocation Algorithms}} in {{Compiler Design}}},&#xA;  date = {2020-12-25T11:23:23+00:00},&#xA;  url = {https://www.geeksforgeeks.org/register-allocation-algorithms-in-compiler-design/},&#xA;  urldate = {2024-03-03},&#xA;  abstract = {A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.},&#xA;  langid = {american},&#xA;  organization = {GeeksforGeeks},&#xA;  file = {/home/john/Zotero/storage/CZH6EUFP/register-allocation-algorithms-in-compiler-design.html}&#xA;}&#xA;&#xA;@book{warrenHackerDelight2003,&#xA;  title = {Hacker&amp;#39;s Delight},&#xA;  author = {Warren, Henry S.},&#xA;  date = {2003},&#xA;  publisher = {Addison-Wesley},&#xA;  location = {Boston},&#xA;  isbn = {978-0-201-91465-8},&#xA;  pagetotal = {306},&#xA;  keywords = {Computer programming}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Clostrum</title>
      <link>//jthing.github.io/cicl-hugo/posts/clostrum/</link>
      <pubDate>Sun, 17 Mar 2024 00:00:00 +0100</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/clostrum/</guid>
      <description>&lt;h2 id=&#34;clostrum&#34;&gt;Clostrum&lt;/h2&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;../images/symbol-store.svg&#34;&gt;&#xA;&lt;/figure&gt;</description>
    </item>
    <item>
      <title>Order of optimizations</title>
      <link>//jthing.github.io/cicl-hugo/posts/order-of-optimation/</link>
      <pubDate>Sat, 16 Mar 2024 00:00:00 +0100</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/order-of-optimation/</guid>
      <description>&lt;h2 id=&#34;order-of-optimizations&#34;&gt;Order of optimizations&lt;/h2&gt;&#xA;&lt;p&gt;For reference here is a replica of a illustration in Munchnick&amp;rsquo;s book&#xA;&amp;lsquo;Advanced compiler design  and implementation&amp;rsquo;&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;../images/Order-of-optimation.svg&#34;&gt;&#xA;&lt;/figure&gt;</description>
    </item>
    <item>
      <title>Compiler</title>
      <link>//jthing.github.io/cicl-hugo/posts/compiler/</link>
      <pubDate>Sat, 09 Mar 2024 00:00:00 +0100</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/compiler/</guid>
      <description>&lt;h2 id=&#34;preliminary-draft-for-compiler-design&#34;&gt;preliminary draft for compiler design&lt;/h2&gt;&#xA;&lt;p&gt;This is a continuation of Strands SICL (SICL implements Common&#xA;Lisp). Although most of the compiler can itself be written in Common&#xA;Lisp  to be a compliant Compiler it must eventually compile  to&#xA;machine code. Today this is done by the SBCL compiler. To make the&#xA;compiler work standalone this will need to be implemented and thus I have drafted this&#xA;proposal. It is criteria that the compiler need to be fast and good. A speed&#xA;goal for the generated code would be to be within a factor of 3 of a C compiler. The&#xA;compiler itself must compile fast similarly to the SBCL compiler today or&#xA;better. As SICL itself it is written in Common lisp.This is a preliminary draft of my&#xA;ideas of how this can be accomplished, subject approval by Dr Strand.&lt;/p&gt;</description>
    </item>
    <item>
      <title>My First Post</title>
      <link>//jthing.github.io/cicl-hugo/posts/my-first-post/</link>
      <pubDate>Fri, 08 Mar 2024 10:28:24 +0100</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/my-first-post/</guid>
      <description>&lt;h2 id=&#34;sicl-compiler&#34;&gt;SICL compiler&lt;/h2&gt;&#xA;&lt;p&gt;This is a blog to describe on-going developement of the SICL compiler.&#xA;It&amp;rsquo;s goal is to convey ideas and research to fellow developers.&#xA;It is NOT intended as veicle for sharing life experiences so if you are looking for that go elsewhere.&lt;/p&gt;&#xA;&lt;p&gt;John aka younder&lt;/p&gt;&#xA;&lt;p&gt;Visit the &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; websize!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Improved GC</title>
      <link>//jthing.github.io/cicl-hugo/posts/inmproved-gc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//jthing.github.io/cicl-hugo/posts/inmproved-gc/</guid>
      <description>&lt;h2 id=&#34;improved-gc&#34;&gt;Improved GC&lt;/h2&gt;&#xA;&lt;p&gt;Hayley&amp;rsquo;s algorithm in initiated by:&lt;/p&gt;&#xA;&lt;p&gt;git clone &lt;a href=&#34;https://github.com/sbcl/sbcl&#34;&gt;https://github.com/sbcl/sbcl&lt;/a&gt;; cd sbcl;SBCL_MAKE_JOBS=&amp;quot;-j&amp;quot; SBCL_MAKE_PARALLEL=42069&#xA;./make.sh &amp;ndash;with-mark-region-gc&lt;/p&gt;&#xA;&lt;p&gt;It&amp;rsquo;s improvement of performance on my machine is pure magic.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
